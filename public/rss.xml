<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Daily Notes]]></title><description><![CDATA[Just Some Notes]]></description><link>https://zhouzh1.github.io</link><generator>RSS for Node</generator><lastBuildDate>Tue, 10 Dec 2019 12:04:29 GMT</lastBuildDate><atom:link href="https://zhouzh1.github.io/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 10 Dec 2019 12:04:29 GMT</pubDate><webMaster><![CDATA[zhouzh1]]></webMaster><item><title><![CDATA[前端优化路径图]]></title><description><![CDATA[<p>微博上看到的关于前端优化的图<br><img src="/site_assets/frontend-optimize.jpg" alt="前端优化图"></p>
]]></description><link>https://zhouzh1.github.io/article/frontend-optimize-image.html.html</link><guid isPermaLink="true">https://zhouzh1.github.io/article/frontend-optimize-image.html.html</guid><pubDate>Tue, 10 Dec 2019 11:32:00 GMT</pubDate></item><item><title><![CDATA[js中的in操作符和Object.keys方法]]></title><description><![CDATA[<h3 id="in-">in操作符</h3>
<p><code>in</code>和<code>typeof</code>一样，只是操作符，不是函数，它用来判断对象是否拥有某个属性，例如：</p>
<pre><code class="lang-js">console.log(&#39;alert&#39; in window); // true
console.log(&#39;xxoo&#39; in window); // false
</code></pre>
<p>在js中，对象的属性查找和继承是基于原型链来实现的，可以使用<code>hasOwnProperty</code>方法判断一个属性是属于对象本身，还是属于它的上层原型：</p>
<pre><code class="lang-js">console.log(window.hasOwnProperty(&#39;alert&#39;)); // true
console.log(([]).hasOwnProperty(&#39;slice&#39;)); // false
</code></pre>
<p><code>in</code>操作符只负责判断在目标对象的原型链上能否找到目标属性，能找到则返回true，否则返回false：</p>
<pre><code class="lang-js">console.log(&#39;slice&#39; in ([])); // true
</code></pre>
<p>同理，<code>for ... in</code>循环也会遍历到对象原型链上的属性：</p>
<pre><code class="lang-js">function Foo() {
    this.foo = &#39;foo&#39;;
}
Foo.prototype.bar = &#39;bar&#39;;
Foo.prototype.__proto__.ox = &#39;ox&#39;;
const f = new Foo();
for (let key in f) {
    console.log(key); // foo bar ox
}
</code></pre>
<p>但是，像<code>__proto__</code>这样的私有属性是不会被遍历到的：</p>
<pre><code class="lang-js">const foo = {};
console.log(foo.hasOwnProperty(&#39;__proto__&#39;)); // false
</code></pre>
<p>当然，js是一门灵活的语言，当通过<code>JSON.parse</code>方法创建对象的时候，可以使得<code>__proto__</code>作为正常属性被遍历，而不是指向对象原型：</p>
<pre><code class="lang-js">const obj = JSON.parse(&#39;{&quot;a&quot;:&quot;a&quot;,&quot;__proto__&quot;:{&quot;b&quot;:&quot;b&quot;}}&#39;);
for (let key in obj) {
    console.log(key); // a __proto__
}
</code></pre>
<p>使用上面描述的方法可能可以在某些代码中发现原型污染漏洞.</p>
<h3 id="object-keys-">Object.keys方法</h3>
<p>Object.keys方法返回一个字符串数组，数组包含目标对象的所有属性名，<code>(o: object) =&gt; string[]</code>，但是只会包含对象本身的属性，上层原型对象上的属性不会包含在数组内：</p>
<pre><code class="lang-js">function Foo() {
    this.foo = &#39;foo&#39;;
    this.oof = &#39;oof&#39;;
}
Foo.prototype.bar = &#39;bar&#39;;
Foo.prototype.__proto__.ox = &#39;ox&#39;;
const f = new Foo();
console.log(Object.keys(f)); // [&#39;foo&#39;, &#39;oof&#39;]
</code></pre>
]]></description><link>https://zhouzh1.github.io/article/the-in-operator-and-object-keys-function.html.html</link><guid isPermaLink="true">https://zhouzh1.github.io/article/the-in-operator-and-object-keys-function.html.html</guid><pubDate>Tue, 10 Dec 2019 08:42:00 GMT</pubDate></item><item><title><![CDATA[洗牌算法]]></title><description><![CDATA[<p>洗牌算法，用于随机打乱一个有限列表内的元素顺序，目前公认最好的洗牌算法就是Fisher-Yates算法，使用JavaScript实现Fisher-Yates算法对一个数组进行顺序打乱的代码如下.</p>
<pre><code class="lang-js">/**
 * Fisher-Yates算法
 * 将数组元素的顺序原地打乱
 * 时间复杂度O(N)
 * @param {Array&lt;any&gt;} 数组
 */
function shuffle(arr) {
    for (let i = arr.length - 1; i &gt; 0; i--) {
        const idx = Math.floor(Math.random() * (i + 1));
        const tmp = arr[i];
        arr[i] = arr[idx];
        arr[idx] = tmp; 
    }
}
</code></pre>
]]></description><link>https://zhouzh1.github.io/article/shuffle-algorithm.html.html</link><guid isPermaLink="true">https://zhouzh1.github.io/article/shuffle-algorithm.html.html</guid><pubDate>Wed, 30 Oct 2019 10:03:00 GMT</pubDate></item><item><title><![CDATA[React中setState方法的同步与异步]]></title><description><![CDATA[<h3 id="this-setstate-">this.setState方法内部做了什么？</h3>
<p>调用this.setState方法后，先进行状态合并，并会触发状态更新，重新调用组件的render方法，render方法执行结束后会产生新的虚拟dom，最后React内部会对组件的新旧虚拟dom进行diff操作，得到针对旧虚拟dom的patch，最后根据patch来更新dom结构，实现视图更新.</p>
<h3 id="this-setstate-">this.setState的同步和异步，为什么这样处理？</h3>
<p>React的setState方法本质上都是同步操作，所谓异步，指的是将一系列的setState操作先收集起来，最终在函数执行结束时进行状态合并后再进行批量执行.</p>
<p>之所以这样做，是因为如前文所述，每次调用setState方法都会触发视图更新，先将多次setState的调用收集起来，最终根据每次setState调用的状态参数进行状态合并后会得到最终的组件状态，这样一来，虽然调用了多次this.setState，但最终只会调用一次组件的render方法，视图也只会更新一次.</p>
<h3 id="-">同步和异步分别发生在什么时机？</h3>
<p>如前文所述，在函数的执行过程中，如果React想对this.setState进行“异步”操作，必须要能知晓这个函数什么时候会执行结束，在React中，组件生命周期函数的执行完全由React控制，事件处理程序由于合成事件的机制也被React所控制，因此在这两类函数里的this.setState都是“异步”处理，对于setTimeout和setInterval以及Promise回调这一类不在React管控范围内的函数里面，所有的this.setState就只能是同步处理了.</p>
<pre><code class="lang-js">import React from &#39;react&#39;;

class Foo extends React.Component {

    state = {
        a: &#39;a&#39;,
    }

    bar() {
        this.setState({
            a: &#39;A&#39;
        });
        console.log(this.state.a); // &#39;a&#39;
    }

    componentDidMount() {
        setTimeout(() =&gt; {
            this.setState({
                a: &#39;A&#39;
            });
            console.log(this.state.a); // &#39;A&#39;
        }, 0);

        Promise.resolve().then(() =&gt; {
            this.setState({
                a: &#39;A&#39;
            });
            console.log(this.state.a); // &#39;A&#39;
        });

        this.setState({
            a: &#39;A&#39;
        });
        console.log(this.state.a); // &#39;a&#39;
    }

    render() {
        return (
            &lt;div onClick={this.bar}&gt;bar&lt;/div&gt;
        )
    }
}
</code></pre>
]]></description><link>https://zhouzh1.github.io/article/sync-and-async-of-react-setState.html.html</link><guid isPermaLink="true">https://zhouzh1.github.io/article/sync-and-async-of-react-setState.html.html</guid><pubDate>Thu, 24 Oct 2019 09:41:00 GMT</pubDate></item><item><title><![CDATA[script标签的async和defer属性]]></title><description><![CDATA[<p>首先，async和defer属性的作用都是指示浏览器加载外联脚本的具体方式，所以两个属性都必须用在外联脚本的script的标签上，否则无效.</p>
<pre><code class="lang-js">&lt;script src=&quot;./a.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;./b.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<h3 id="-async-defer">不使用async和defer</h3>
<p>正常情况下，script标签会阻塞浏览器对HTML文档的解析，遇到script标签，浏览器会遵循下列步骤：<br>下载脚本 → 运行脚本 → 继续解析后面的文档内容.</p>
<h3 id="async">async</h3>
<p>async指示浏览器以异步的方式并行下载脚本，脚本下载过程中不会阻塞浏览器对HTML文档的解析，脚本下载完成后立即执行，因此脚本的执行顺序不确定，与script标签在HTML文档的顺序不一定保持一致.</p>
<h3 id="defer">defer</h3>
<p>defer指示浏览器先以并行方式下载脚本，也不会阻塞浏览器，与async不同的是，使用defer属性的脚本下载完成之后不会立即执行，而是在所有的defer脚本下载完成之后，并在DOMContentLoaded事件触发前按照script标签在HTML文档中的顺序执行.</p>
<h3 id="-">总结</h3>
<p>对script标签使用async和defer属性可以减少页面脚本总的下载时间，进而减少页面的白屏时间.</p>
]]></description><link>https://zhouzh1.github.io/article/async-and-defer-attribute-of-script-tag.html.html</link><guid isPermaLink="true">https://zhouzh1.github.io/article/async-and-defer-attribute-of-script-tag.html.html</guid><pubDate>Wed, 23 Oct 2019 10:07:00 GMT</pubDate></item><item><title><![CDATA[js中的对象继承方式以及优劣对比分析]]></title><description><![CDATA[<h3 id="-">原型链继承</h3>
<pre><code class="lang-js">// 父类构造函数
function Parent() {
    this.name = &#39;John&#39;;
    this.habits = [&#39;basketball&#39;, &#39;cook&#39;, &#39;boxing&#39;];
}
// 父类原型
Parent.prototype.sayHello = function sayHello() {
    console.log(&#39;hello, world&#39;);
}
// 子类构造函数
function Child() {
    // @empty
}
// 将子类的原型指向父类的一个实例
Child.prototype = new Parent();

const child_1 = new Child();
console.log(child_1.name); // John
console.log(child_2.habits); // [&#39;basketball&#39;, &#39;cook&#39;, &#39;boxing&#39;]
const child_2 = new Child();
console.log(child_1.habits === child_2.habits); // true
child_1.habits.push(&#39;running&#39;);
console.log(child_1.habits); // [&#39;basketball&#39;, &#39;cook&#39;, &#39;boxing&#39;, &#39;running&#39;]
</code></pre>
<p><strong>缺点</strong>：父类实例中的引用类型对象由所有的子类实例共享，只要其中一个子类实例对其进行了修改，便会影响其他子类实例，容易“牵一发动全身”，造成容易忽略的BUG.</p>
<h3 id="-">构造函数继承</h3>
<pre><code class="lang-js">function Parent(name) {
    this.name = name;
    this.habits = [&#39;boxing&#39;];
    this.sayHello = function sayHello() {
        console.log(&#39;hello, world!&#39;);
    }
}

function Child() {
    Parent.call(this, &#39;frank&#39;);
}

const child_1 = new Child();
const child_2 = new Child();
child_1.habits.push(&#39;cooking&#39;);
console.log(child_1.habits); // [&#39;boxing&#39;, &#39;cooking&#39;]
console.log(child_2.habits); // [&#39;boxing&#39;]
console.log(child_1.sayHello === child_2.sayHello); // false
</code></pre>
<p><strong>优点</strong>：</p>
<ol>
<li>与原型链的方式相比，解决了不同的子类实例共享原型链上的引用类型对象的问题，因为所有的子类实例都拥有属于自身的属性；</li>
<li>在子类构造函数中调用父类构造函数的同时，可以传递参数，实现不同的子类实例上的属性保存不同的值</li>
</ol>
<p><strong>缺点</strong>：对象方法附加在实例上，每创建一个子类实例，就会将相关的方法也创建一遍，而函数的创建需要占用内存空间</p>
<h3 id="-">原型链-构造函数组合式继承</h3>
<pre><code class="lang-js">function Parent(name) {
    this.name = name;
    this.habits = [&#39;boxing&#39;];
}
Parent.prototype.sayHello = function sayHello() {
    console.log(&#39;hello, world&#39;);
}

function Child(name) {
    Parent.call(this, name);
}

Child.prototype = new Parent();

const child_1 = new Child(&#39;trump&#39;);
const child_2 = new Child(&#39;willianm&#39;);
console.log(child_1.sayHello === child_2.sayHello); // true
</code></pre>
<p><strong>优点</strong>：结合了原型链和构造函数两种方式的优势，既解决了子类实例共享引用类型属性的问题，又实现了对象方法只需要创建一次即可<br><strong>缺点</strong>：</p>
<ol>
<li>每创建一个子类实例，需要调用两次父类构造函数；</li>
<li>子类实例和子类实例的原型上存在同名属性，造成冗余.</li>
</ol>
<h3 id="-">原型式继承</h3>
<pre><code class="lang-js">function createObj(parentObj) {
    function F() {}
    F.prototype = parentObj;
    return new F();
} 
const parent = {
    habits: [&#39;boxing&#39;]
};
const child = createObj(parent);
</code></pre>
<p>本质上和ES6的<code>Object.create</code>方法一样，只是改变了子类构造函数的原型对象，缺点和基于原型链的继承方式一样.</p>
<h3 id="-">寄生式继承</h3>
<pre><code class="lang-js">function createObj(parentObj) {
    const childObj = Object.create(parentObj);
    childObj.sayHello = function sayHello() {
        console.log(&#39;hello, world&#39;);
    }
}
</code></pre>
<p>和基于构造函数实现继承的方式相比，省略了父类构造函数的调用，但是两种方式缺点一样.</p>
<h3 id="-">寄生-组合式继承</h3>
<pre><code class="lang-js">function Parent() {
    this.firstName = &#39;gates&#39;;
}

Parent.prototype.sayHello = function sayHello() {
    console.log(&#39;hello, world&#39;);
}

function Child(lastName) {
    Parent.call(this);
    this.lastName = lastName;
}

const prototype = Object.create(Parent.prototype);
Child.prototype = prototype;
prototype.constructor = Child;

// 寄生-组合式方法封装
function inheritance(Child, Parent) {
    const prototype = Object.create(Parent);
    Child.prototype = prototype;
    prototype.constructor = Child;
}
</code></pre>
<p>从名字就可以看出，这种方式集成了寄生和组合方式的优点，绕过了组合方式需要两次调用父类构造函数以及属性冗余的问题.</p>
]]></description><link>https://zhouzh1.github.io/article/js-inheritance.html.html</link><guid isPermaLink="true">https://zhouzh1.github.io/article/js-inheritance.html.html</guid><pubDate>Tue, 08 Oct 2019 10:23:00 GMT</pubDate></item></channel></rss>